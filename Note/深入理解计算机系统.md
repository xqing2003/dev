# 深入理解计算机系统
## 信息的表示和处理
  - 信息存储
    - 十六进制表示$$2 
n
 的十六进制表示：n=i+4*jn=i+4∗j i(0-3),j个0,例 2^4 4=0(i)+4*1(j)2 
4
 4=0(i)+4∗1(j) 0x10$$word
      - 决定虚拟地址空间大小
    - 数据大小
    - 寻址和字节顺序
      - Little endian： 大多数intel 兼容机器使用
      - Big endian  ： 大多数ibm和sun microsystems使用；网络字节序也是big endian
      - 语言相关：
        - C/C++检测: union
        - Golang：系统库binary.BigEndian binary.LittleEndian
    - 表示字符串
      - ASCII 、UTF8、Unicode
    - 表示代码
    - 布尔代数
      - 与& 或| 异或^ 非~
(a^b)^a=b
用位向量表示有限集合:
   位向量$$[a_{w-1},...a_1, a_0]可编码任何子集A\subseteq\{0,1, ...,w-1\}$$,可用位向量的|作为集合并、&作为集合交、~作为集合补
      - C语言的位运算：与& 或| 异或^ 非~
        - 掩码：0xff/0x7f
      -    Go的位运算：与& 、或|、 异或^、位清空&^(and not)
位清空：a&^b = and(a, not(b)) ；0xa1&^1 = 0xa0   a&^0=a;  byte(a) &^(0xff)=0
      -   逻辑运算
      - 移位运算：<< >> 逻辑右移、算术右移（高位填充符号位，有符号使用该方式）
    - 
  - 整数表示
    - 补码编码：有符号数用补码表示，范围不对称 |TMin| = |TMax|+1
      - 原码 反码
    - 有符号和无符号数的转换：c语言对同时有有符号和无符号的数据运算，会隐式将有符合强制成无符号，并假设两个数是非负的执行运算。
    - 扩展（extension）：无符号高位补0（zero extension）；有符号在高位补符合（sign extension），signed short(-12345)=0xcfc7 signed int(-12345)=0xffffcfc7
    - 截断
    - 有符号数和无符号数的限制：一般尽量不用无符号数；作为位集合时可用无符号数
  - 整数运算
    - 无符号加法
    - 补码加法
    - 补码非
    - 无符号乘法
    - 补码乘法
    - 乘以常数：大多数机器上乘法（10个或更多时钟周期）比加、减、位运算和移位（1个时钟周期）差10倍；大多数编译器把乘法优化为移位和加减组合$$x*k 将k拆成2的倍数表示再组合运算$$
    - 除以2的幂：除法需要30个或更多，拆成移位和加减组合
    - 整数运算思考：慎用unsigned
  - 浮点数
    - 二进制小数
$$b_w,b_{w-1},...b_1,b_0.b_{-1},b_{-2}...,b_{-n}$$
    - IEEE浮点表示：
$$V=(-1)^s \times M\times 2^E$$
      - S: 符号位 一位；
      - k: 阶码位数k$$Exp(E)=e_{k-1}...e_1.e_0$$，32位k=8,64位 k=11
      - n：小数字段位数n,32位n=23，64位n=52
        - exp既不全0也不全1时，小数点前的1舍去，表示的为n+1，可表示24位
          -   E=e-Bias???
          - $$M=1+f=1.f_{n-1}f_{n-2}...f_0$$
        - exp全0时：M=f,不包含隐式的1
        - exp全1时：表示正负无穷
    - 数字示例

    - 四种舍入方式（五种）
      - Round to even(向偶数舍入，也称为round to nearest)，默认舍入方式，四舍五入到最近
      - 向零舍入：-1.5 ->-1  2.6->2
      - 向下舍入：floor
      - 向上舍入：ceil
## 程序的机器级表示

### 程序编码

>  c/c++源码到可执行文件过程:
>
>  预处理，头文件展开、宏展开、条件编译等，生成.i文件；gcc -E
>
>  编译，检查语法 生成汇编代码.s; gcc -S
>
>  汇编，转换成机器码，生成.obj，代码段和数据段; gcc -c
>
>  链接，将目标链接在一起生成可执行文件；

#### 机器级代码

Objdump -d

AT&T格式汇编：

操作数从左到右；寄存器前%；mov(b/w/l/q);mov 8(%ebp)

Intel格式：操作数从右到左；mov [ebp+8]

### 数据格式

### 访问信息 
IA32 CPU包含8个32位值的寄存器：

eax（ah al） ebx ecx edx   

esi edi  esp ebp

#### 三种操作数：

立即数（常数值）Imm：AT&T 用$num（$123 or $0x1F） 表示立即数

寄存器(E)：

存储器引用：用计算出的地址访问存储器
  :$$Imm(E_b，E_i，s) = M[Imm+Reg[E_b]+R[E_i].s]；其中Imm为立即数，E_b为基址寄存器E_i为变址寄存器，比例因子s(1,2,4,8)$$指令：操作码 地址码  OP A1 A2 A3

 直接寻址：地址码给出有效地址

 间接寻址：地址码给出的是指向有效地址的地址[m]，存的指向地址的指针；

 寄存器寻址：操作数在寄存器里

 寄存器间接寻址：操作数的地址在寄存器里 存的指向地址的指针；

**偏移寻址：**

 基址寻址: EBX(基址寄存器)的内容+地址码中的形式地址，基地址不变，改变形式地址；优点：可扩大寻址范围，；基址寄存器内容由操作系统或管理程序确定，主要用于为程序和数据分配存储空间；
 
 变址寻址：形式地址不变，变址寄存器改变；变址寄存器由用户设定且可变，指令中地址码不变；主要用来处理数组字符串遍历，适用于循环。

  相对寻址：

#### 数据传输指令：
- mov指令：mov S, D //AT&T S->D
  mov(b/w/l): movb(byte)、movw(word)、movl(double word) 

  movs(符号扩展): 符号扩展(S)->D movsbw ()
  
  